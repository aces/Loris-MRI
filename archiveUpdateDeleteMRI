#! /usr/bin/perl

=pod

This script is very useful if the MRI pipeline needs to be re-run on the whole study dataset.

What this script does:
- renaming the assembly, jiv, pic folders as assembly_bkp`date`
- deleting all MRI data in the database from the files, parameter_file and mri_acquisition_dates
- updating the ArchiveLocation in the tarchive table

This script interacts with the NeuroDB database system. It will connect to/deal with/ modify contents of the following tables:
parameter_file, files, 

=cut

use strict;
use Carp;
use Getopt::Tabular;
use FileHandle;
use File::Basename;
use File::Temp qw/ tempdir /;
use File::Path 'remove_tree';
use Data::Dumper;
use FindBin;
use Cwd qw/ abs_path /;

# These are the NeuroDB modules to be used
use lib "$FindBin::Bin";
use uploadNeuroDB::NeuroDB::File;
use uploadNeuroDB::NeuroDB::DBI;
use uploadNeuroDB::NeuroDB::Notify;

## Starting the program
my $versionInfo     = sprintf "%d revision %2d", q$Revision: 1.2 $ =~ /: (\d+)\.(\d+)/;
# needed to rename the assembly,pic and jiv folders
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =localtime(time);
my $logDate         = sprintf("%4d-%02d-%02d %02d:%02d:%02d",$year+1900,$mon+1,$mday,$hour,$min,$sec);
my $archiveDate     = sprintf("%4d-%02d-%02d",$year+1900,$mon+1,$mday);
my $message         = '';
my $profile         = undef;    # this should never be set unless you are in a stable production environment
my $archiveData     = 0;        # default should be 0
my $updateTarchive  = 0;        # default should be 0
my $deleteMRItables = 0;        # default should be 0
my $all             = 0;        # default should be 0
my $list            = undef;
my $xlog            = 0;        # default should be 0

my @opt_table = (
            ["Basic options","section"],
            ["-profile","string",1,\$profile,"name of config file in ~/.neurodb."],
            ["-archive","boolean",1,\$archiveData,"Will archive the data stored in assembly, jiv, pic and tarchive/year folders"],
            ["-update","boolean",1,\$updateTarchive ,"Will update the ArchiveLocation in the tarchive table"],
            ["-delete","boolean",1,\$deleteMRItables ,"Will delete all the data stored in assembly, jiv, pic and tarchive/year folders, as well as all data stored in the files, parameter_file and mri_acquisition_dates tables"],
            ["-all","boolean",1,\$all,"Will perform the -update and -delete options on all MRI data. If not running the script on all data, specify the list in the -list argument."],
            ["-list","string",1,\$list,"List of tarchives (with full path) stored in a text file."],
            ["Fancy options","section"],
            ["-xlog", "boolean", 1, \$xlog, "Open an xterm with a tail on the current log file."],
);

my $Help = <<HELP;
*****************************************************************************
UNLOAD TARCHIVE
*****************************************************************************

Author  :   Cecile Madjar using the NeuroDB lib
Date    :   2012/10/17
Version :   $versionInfo

This looks for all tarchives stored in $Settings::tarchiveLibraryDir and performs a lot of magic:

- archive the assembly, jiv, pic and tarchive/year folders to MRIPipelineData_bkp`date`.tar
- update the ArchiveLocation in the tarchive table to the tarchives's location
- delete all entries in the files, parameter_file and mri_acquisition_dates tables AND delete contents of the assembly, jiv, pic and tarchive/year folders.

When running the update or delete section, you can choose to run it on the entire dataset or a subset of tarchives that will be listed in a text file (one tarchive per line without the full path). 

Enjoy!!

HELP
my $Usage = <<USAGE;
usage: $0 </path/to/DICOM-tarchive> [options]
       $0 -help to list options
USAGE
&Getopt::Tabular::SetHelp($Help, $Usage);
&Getopt::Tabular::GetOptions(\@opt_table, \@ARGV) || exit 1;

# input option error checking
{ package Settings; do "$ENV{HOME}/.neurodb/$profile" }
if ($profile && !defined @Settings::db) { print "\n\tERROR: You don't have a configuration file named '$profile' in:  $ENV{HOME}/.neurodb/ \n\n"; exit 33; }
if(!$profile) { print $Help; print "$Usage\n\tERROR: You must specify an existing profile.\n\n";  exit 33;  }
if($updateTarchive && !$all && !$list){ print $Help; print "$Usage\n\tERROR: You must specify either a list of tarchives (using -list) or -all.\n\n";  exit 33;  }
if($deleteMRItables && !$all && !$list){ print $Help; print "$Usage\n\tERROR: You must specify either a list of tarchives (using -list) or -all.\n\n";  exit 33;  }
############################################################################################
# These settings are in a config file (profile)
my $data_dir        = $Settings::data_dir;
my $assembly_dir    = $data_dir.'/assembly'; 
my $pic_dir         = $data_dir.'/pic';
my $jiv_dir         = $data_dir.'/jiv';
my $tarchive_dir    = $Settings::tarchiveLibraryDir;
my $archives_dir    = $data_dir."/ARCHIVES";

my $User             = `whoami`; # fixme
my $template         = "ArchiveLocationUpdate-$hour-$min-XXXXXX"; # for tempdir

# create the temp dir
my $TmpDir = tempdir($template, TMPDIR => 1, CLEANUP => 1 );

# create logdir(if !exists) and logfile
my @temp     = split(/\//, $TmpDir);
my $templog  = $temp[$#temp];
my $LogDir   = "$data_dir/logs/archiveUpdateDeleteMRI"; if (!-d $LogDir) { mkdir($LogDir, 0700); }
my $logfile  = "$LogDir/$templog.log";
open LOG, ">$logfile";
LOG->autoflush(1);
&logHeader();

# if xlog is set, fork a tail on log file.
my $childPID; if ($xlog) { $childPID = fork(); if($childPID == 0) { exec("xterm -geometry 130x70 -e tail -f $logfile"); exit(0); } }

# establish database connection
my $dbh = &NeuroDB::DBI::connect_to_db(@Settings::db);
print LOG "\t==> Successfully connected to database.\n";


##################################
# Get the list of tarchive files #
##################################
my @tarchive_list;

if($all){
    @tarchive_list=glob("$tarchive_dir/*.tar");
}elsif($list){
    open(TARCHIVES,"<$list");
    @tarchive_list=<TARCHIVES>;
    close(TARCHIVES);
}elsif(!$updateTarchive){ 
    print LOG "\n*** The tarchive table won't be updated.\n";
}


########################################
# Archive the MRI pipeline directories #
########################################
if($archiveData==1){

    my ($totar);
    chdir($data_dir);
    if ($all){

        my @tmp=glob(basename($tarchive_dir)."/1* ".basename($tarchive_dir)."/2* ".basename($assembly_dir)." ".basename($pic_dir)." ".basename($jiv_dir));
        $totar=join(' ',@tmp);
        print LOG "\n*** All MRI ($totar) data will be archived.\n";

    }elsif ($list){

        my (@list_totar);
        foreach my $tarchive(@tarchive_list){
            chomp($tarchive);
            my $tarchive_name=substr(basename($tarchive),0,-4);
            my ($SessionID,$CandID,$Visit_label) = getSessionInfo($tarchive_name,$dbh); 

            my @tmp=glob(basename($assembly_dir)."/$CandID/$Visit_label ".basename($jiv_dir)."/$CandID/*$Visit_label* ".basename($pic_dir)."/$CandID/*$Visit_label* ".basename($tarchive_dir)."/1*/$tarchive_name* ".basename($tarchive_dir)."/2*/$tarchive_name*");
            push(@list_totar,@tmp);
        }
        $totar=join(' ',@list_totar);
    }

    unless (-e "$archives_dir" or mkdir $archives_dir){$message = "\n ERROR: Unable to create directory $archives_dir!\n\n"; &writeErrorLog($logfile, $message, 77); exit 77;} 
    
    my $tar_file=$archives_dir."/MRIPipelineData_bkp_$archiveDate.tar.gz";
    if (-e $tar_file){
        $message = "\n ERROR: $tar_file already exist!\n\n"; 
        &writeErrorLog($logfile, $message, 77); exit 77;
    }else{
        print LOG "\t==> Archiving the assembly, jiv and pic folders in $tar_file.\n";
        `tar -czf $tar_file $totar`;
    }

}else{ 
    
    print LOG "\n*** MRI data won't be archived.\n";
    
}


################################################################
# Get the list of tarchive files and update the tarchive table #
################################################################
foreach my $tarchive(@tarchive_list){
    chomp($tarchive);
    my $tarchive_name   =   substr(basename($tarchive),0,-4);
    print LOG "\n*** Location of source data    : $tarchive \n";

    my ($tarchiveID)    =   getTarchiveID($tarchive_name,$dbh);

    print LOG "\t==> Updating ArchiveLocation of tarchive $tarchiveID to $tarchive_name.\n";
    
    my ($success)       =   updateArchiveLocation($tarchive,$tarchiveID,$dbh);
    if ($success){
        print LOG "\t==> Updated ArchiveLocation of tarchive $tarchiveID to $tarchive_name.\n";
    } else {
        print LOG "\n ERROR: Could not update ArchiveLocation of tarchive $tarchiveID to $tarchive_name.\n";
    }
}


#############################################################################
# Delete all entries in the files, parameter_file and mri_acquisition_dates #
#############################################################################
my @delete_list;

if($deleteMRItables && $all){
    print LOG "\n*** All files and tables' content will be deleted.\n";
    
    # delete the content of the assembly, jiv, pic and tarchive/year folders
    my @remove_list=glob "$assembly_dir $jiv_dir $pic_dir $tarchive_dir/1* $tarchive_dir/2*";
    remove_tree(@remove_list, {keep_root => 1, result => \my $res_list});
    if (@$res_list==0){
        print LOG "\t==> No files were deleted.\n";
    }else{
        print LOG "\t==> Removed all MRI data stored in the assembly, jiv, pic and tarchive/year folders.\n";
    }
    
    # delete the content of the files, parameter_file and mri_acquisition_dates
    my $query = "DELETE f, pf, mad FROM files AS f LEFT JOIN parameter_file as pf ON f.FileID=pf.FileID LEFT JOIN mri_acquisition_dates AS mad ON f.SessionID=mad.SessionID";
    my $sth = $dbh->prepare($query);
    $sth->execute;
    
    if($sth->rows == 0){ print LOG "\t==> No entries were deleted.\n";}
    else{ my $row = $sth->rows; print LOG "\t==> $row entries were deleted.\n"}

}elsif($deleteMRItables && $list){
    
    open(TARCHIVES,"<$list");
    my @tarchive_list=<TARCHIVES>;
    close(TARCHIVES);

    foreach my $tarchive(@tarchive_list){
        chomp($tarchive);
        my $tarchive_name=substr(basename($tarchive),0,-4);
        print LOG "\n*** Deleting files and tables' entries of $tarchive.\n";

        my ($SessionID,$CandID,$Visit_label) = getSessionInfo($tarchive_name,$dbh); 

        my @remove_list=glob "$assembly_dir/$CandID/$Visit_label $jiv_dir/$CandID/*$Visit_label* $pic_dir/$CandID/*$Visit_label* $tarchive_dir/1*/$tarchive_name* $tarchive_dir/2*/$tarchive_name*";
        remove_tree(@remove_list, {result => \my $res_list});
        if (@$res_list==0){
            print LOG "\t==> No files were deleted.\n";
        }else{
            print LOG "\t==> List of removed files:\n";
            print LOG "$_\n" for @$res_list;
        }

        my $sth=$dbh->prepare("DELETE f, pf, mad FROM files AS f LEFT JOIN parameter_file as pf ON f.FileID=pf.FileID LEFT JOIN mri_acquisition_dates AS mad ON f.SessionID=mad.SessionID WHERE f.SessionID=$SessionID");
        $sth->execute;
        
        if($sth->rows == 0){ print LOG "\t==> No entries for session $SessionID were found.\n";}
        else{ my $row = $sth->rows; print LOG "\t==> $row entries were deleted for session $SessionID.\n"}
    }

}elsif(!$deleteMRItables){  print LOG "\n*** Files and contents of tables won't be deleted.\n";}





##################################
# Functions called in the script #
##################################
sub logHeader () {
        print LOG "
--------------------------------------------------------------------------------------------
                                             AUTOMATED DICOM DATA UPLOAD
--------------------------------------------------------------------------------------------
*** Date and time of update    : $logDate
*** tmp dir location           : $TmpDir
\n";
}

# this is a useful function that will close the log and write error messages in case of abnormal program termination
sub writeErrorLog {
    my ($logfile, $message, $failStatus, ) = @_;
    print LOG $message;
    print LOG "program exit status: $failStatus";
    `cat $logfile >> $LogDir/error.log`;
    close LOG;
    `rm -f $logfile`;
}

=pod
Fetches SessionID, CandID and Visit_label from the tarchive/session tables based on $tarchive_name.
=cut
sub getSessionInfo {
    my ($tarchive_name,$dbh) = @_;

    my $like = "%$tarchive_name%";
    my $query = "SELECT t.SessionID, s.CandID, s.Visit_label FROM tarchive AS t LEFT JOIN session AS s ON s.ID=t.SessionID WHERE ArchiveLocation LIKE ?";
    my $sth = $dbh->prepare($query);
    $sth->execute($like);

    my ($SessionID,$CandID,$Visit_label);
    if ($sth->rows > 0) {
        my $row = $sth->fetchrow_hashref();
        $SessionID  =   $row->{'SessionID'};
        $CandID     =   $row->{'CandID'};
        $Visit_label=   $row->{'Visit_label'};
    } else {
        $message = "\n ERROR: No SessionID, CandID and Visit_label are associated to the Archive $tarchive_name or the Archive is not a valid archive for this study!\n\n";
        &writeErrorLog($logfile, $message, 77); exit 77;
    }

    return ($SessionID,$CandID,$Visit_label);
}

=pod
Fetches TarchiveID from the tarchive table based on $tarchive_name.
=cut
sub getTarchiveID {
    my ($tarchive_name,$dbh) = @_;

    my $like    =   "%$tarchive_name%"
    my $query   =   "SELECT TarchiveID FROM tarchive WHERE ArchiveLocation LIKE ?";
    my $sth     =   $dbh->prepare($query);
    $sth->execute($like);

    my $tarchiveID;
    if ($sth->rows > 0) {
        my $row = $sth->fetchrow_hashref();
        $tarchiveID = $row->{'TarchiveID'};
    } else { 
        $message = "\n ERROR: Only archived data can be updated. This seems not to be a valid archive for this study!\n\n"; 
        &writeErrorLog($logfile, $message, 77); exit 77;
    }

    return ($tarchiveID);
}

sub udpateArchiveLocation {
    my ($tarchive,$tarchiveID,$dbh) =   @_;

    my $query   =   "UPDATE tarchive SET ArchiveLocation=? WHERE TarchiveID=?";
    my $sth     =   $dbh->prepare($query);
    $sth->execute($tarchive,$tarchiveID) or return 0;

    return 1;
}
